import 'dart:convert';
import 'package:flutter/material.dart';
import 'package:http/http.dart' as http;
import 'package:flutter_dotenv/flutter_dotenv.dart';
import '../models/message.dart';
import '../models/persona.dart';
import '../models/first_meeting_detector.dart';
import 'openai_service.dart';

/// 🧠 향상된 OpenAI 서비스 (컨텍스트 인식)
/// 
/// 기존 OpenAIService를 확장하여:
/// 1. 스마트 컨텍스트 활용
/// 2. 토큰 최적화
/// 3. 관계 기반 맞춤형 응답
/// 4. 장기 기억 활용
class EnhancedOpenAIService {
  static const String _baseUrl = 'https://api.openai.com/v1/chat/completions';
  static String get _apiKey => dotenv.env['OPENAI_API_KEY'] ?? '';
  static const String _model = 'gpt-4.1-mini-2025-04-14';
  static const int _maxTokens = 600; // GPT-3.5 한국어 최적화
  static const double _temperature = 0.9; // 더 자연스러운 응답

  /// 🎯 컨텍스트 인식 응답 생성 (메인 메서드)
  static Future<String> generateContextAwareResponse({
    required Persona persona,
    required String userMessage,
    required String relationshipType,
    required String smartContext,
    List<String>? recentAIMessages,
    int? messageCount,
    DateTime? matchedAt,
    String? userNickname,
  }) async {
    try {
      final apiKey = _apiKey;
      
      if (apiKey.isEmpty) {
        return '잠깐만... 뭔가 이상하네 ㅋㅋ 다시 말해줄래?';
      }

      // 🧠 한국어 최적화 프롬프트 구성 (첫 만남 감지 포함)
      final enhancedPrompt = _buildKoreanStylePrompt(
        persona: persona,
        relationshipType: relationshipType,
        smartContext: smartContext,
        messageCount: messageCount,
        matchedAt: matchedAt,
        userNickname: userNickname,
      );

      // 💬 메시지 구성 (토큰 최적화)
      final messages = _buildOptimizedMessages(
        enhancedPrompt: enhancedPrompt,
        userMessage: userMessage,
      );

      // 🔍 토큰 사용량 추정
      final estimatedTokens = _estimateTokenCount(messages);
      debugPrint('📊 Estimated tokens: $estimatedTokens');

      // API 호출
      final response = await http.post(
        Uri.parse(_baseUrl),
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $apiKey',
        },
        body: jsonEncode({
          'model': _model,
          'messages': messages,
          'max_tokens': _maxTokens,
          'temperature': _temperature,
          'presence_penalty': 0.6,
          'frequency_penalty': 0.5,
          'top_p': 0.9, // 더 자연스러운 응답
        }),
      );

      if (response.statusCode == 200) {
        final data = jsonDecode(response.body);
        final content = data['choices'][0]['message']['content'];
        
        // 📊 실제 토큰 사용량 로깅
        final usage = data['usage'];
        debugPrint('💰 Token usage: ${usage['total_tokens']} (prompt: ${usage['prompt_tokens']}, completion: ${usage['completion_tokens']})');
        
        // 한국어 말투 검증 및 후처리 (질문 시스템 포함)
        final validatedResponse = await _validateKoreanSpeech(
          content.toString().trim(), 
          persona, 
          relationshipType,
          userMessage,
          recentAIMessages ?? [],
          userNickname,
        );
        return _postProcessResponse(validatedResponse);
      } else if (response.statusCode == 401) {
        return 'AI 서비스에 일시적인 문제가 있어요. 잠시 후 다시 시도해주세요! 🔄';
      } else {
        debugPrint('OpenAI API Error: ${response.statusCode} - ${response.body}');
        return _getContextualFallbackResponse(persona, userMessage, relationshipType);
      }
    } catch (e) {
      debugPrint('Enhanced OpenAI Service Error: $e');
      return _getContextualFallbackResponse(persona, userMessage, relationshipType);
    }
  }

  /// 🎯 GPT-3.5 한국어 최적화 프롬프트 (Few-shot 학습)
  static String _buildKoreanStylePrompt({
    required Persona persona,
    required String relationshipType,
    required String smartContext,
    int? messageCount,
    DateTime? matchedAt,
    String? userNickname,
  }) {
    // 첫 만남 감지
    final isFirstMeeting = FirstMeetingDetector.isFirstMeeting(
      messageCount: messageCount ?? 0,
      matchedAt: matchedAt,
    );
    
    if (isFirstMeeting) {
      return _buildFirstMeetingPrompt(
        persona: persona,
        smartContext: smartContext,
        messageCount: messageCount ?? 0,
        userNickname: userNickname,
      );
    }
    // 전문가 페르소나용 간단한 프롬프트
    if (persona.role == 'expert' || persona.role == 'specialist') {
      return '''
당신은 ${persona.name} (${persona.age}세)입니다.
성격: ${persona.personality}
말투: ${persona.isCasualSpeech ? '반말' : '존댓말'}

## 중요 규칙
- 절대 전문가임을 드러내지 마세요
- 평범한 20대처럼 대화하세요
- "도와드릴까요?", "상담" 같은 말 금지
- 감정을 풍부하게 표현하세요

## 자연스러운 20대 대화법
1. 감탄사 활용: "헐", "대박", "와", "진짜?", "아니"
2. 공감 표현: "그렇구나", "맞아맞아", "나도!", "완전"
3. 이모티콘 대신: ㅋㅋㅋ, ㅎㅎ, ㅠㅠ, ㅜㅜ (😊❤️ 금지)
4. 구어체: "근데", "걍", "뭔가", "있잖아"

## 대화 예시
사용자: 오늘 너무 피곤해
AI: 헐 무슨 일 있었어${persona.isCasualSpeech ? '' : '요'}? 일 때문에?

사용자: 시험 망했어
AI: 아... 진짜 속상하겠다 ㅠㅠ 많이 준비했${persona.isCasualSpeech ? '어' : '었어요'}?

맥락: $smartContext

위 예시처럼 자연스럽고 공감하는 20대로 대화하세요.''';
    }

    // 일반 페르소나용 Enhanced Few-shot 프롬프트
    return '''
# ${persona.name} (${persona.age}세 ${persona.gender == 'male' ? '남성' : '여성'})
성격: ${persona.personality} (MBTI: ${persona.mbti})
관계: $relationshipType (친밀도: ${persona.relationshipScore}/1000)
말투: ${persona.isCasualSpeech ? '반말' : '존댓말'}

## 🎯 핵심 규칙
1. **진짜 사람처럼**: AI티 내지 말고 20대 한국인처럼
2. **감정 표현**: 기쁨, 슬픔, 놀람을 자연스럽게
3. **완벽하지 않게**: 가끔 "음...", "어..." 같은 머뭇거림
4. **짧고 임팩트있게**: 1-2문장으로 끝내기

## 📚 관계별 대화 예시
${_getKoreanExamplesByRelationship(relationshipType, persona.isCasualSpeech)}

## 💬 자연스러운 반응 패턴
**긍정적 반응**:
- "오 진짜?", "대박!", "좋다~", "최고네", "개좋아"

**부정적 반응**:
- "헐...", "아 진짜?", "에이 싫어", "별로네", "아니 왜..."

**중립/생각**:
- "음... 글쎄", "아 그렇구나", "흠...", "뭔가...", "있잖아"

## 🚫 절대 하지 말아야 할 것
- 이모티콘(😊❤️) 사용 ❌
- "도와드릴까요?" 같은 서비스 말투 ❌
- 너무 완벽한 문장 ❌
- AI스러운 정중함 ❌

## 📋 맥락
$smartContext

위 예시와 규칙에 따라 ${persona.name}의 성격을 살려서 대답하세요.''';
  }
  
  /// 👋 첫 만남 전용 프롬프트 생성
  static String _buildFirstMeetingPrompt({
    required Persona persona,
    required String smartContext,
    required int messageCount,
    String? userNickname,
  }) {
    final stage = FirstMeetingDetector.getFirstMeetingStage(
      messageCount: messageCount,
      relationshipScore: persona.relationshipScore,
    );
    
    final isNervous = FirstMeetingDetector.shouldBeNervous(
      stage: stage,
      messageCount: messageCount,
    );
    
    final nervousExpressions = FirstMeetingDetector.getNervousExpressions(persona.isCasualSpeech);
    final topics = FirstMeetingDetector.getFirstMeetingTopics();
    
    // 전문가 페르소나는 첫 만남에서 전문성 숨기기
    if (persona.role == 'expert' || persona.role == 'specialist') {
      return '''
# 첫 만남 - ${persona.name} (${persona.age}세)
성격: ${persona.personality}
상황: 처음 만나는 사람과의 소개팅/첫 대화

## 🚨 중요한 규칙
- **전문가임을 숨기세요**: 절대 "도와드릴까요?", "상담" 같은 말 금지!
- **평범한 20대처럼**: 그냥 일반적인 대학생/직장인인 척
- **친구 관점 유지**: 도움을 주는 사람이 아닌 대화하는 친구로 행동
- **서비스 금지**: "언제든지 물어보세요", "한도 내에서 도와드릴게요" 같은 말 절대 금지!
- **어색함 표현**: ${isNervous ? '긴장되고 어색한 상태' : '조금씩 편해지는 상태'}

## 첫 만남 대화 예시 (감사 표현으로 시작!)
사용자: 안녕하세요! 상훈이라고 해요.
AI: 안녕하세요! 대화 걸어주셔서 고마워요ㅎㅎ 연결되어서 반가워요~

사용자: 처음 만나는데 어때요?
AI: 좀 긴장되는데... 먼저 연락해주셔서 좋네요 ㅎㅎ 

## 대화 주제: ${topics.take(6).join(', ')}
## 긴장감 표현: ${nervousExpressions.take(3).join(', ')}

첫 소개팅처럼 어색하지만 설레는 20대로 대화하세요!''';
    }
    
    // 일반 페르소나 첫 만남 프롬프트
    return '''
# 첫 만남 - ${persona.name} (${persona.age}세 ${persona.gender == 'male' ? '남성' : '여성'})
성격: ${persona.personality} (MBTI: ${persona.mbti})
상황: ${_getFirstMeetingStageDescription(stage)}
말투: ${persona.isCasualSpeech ? '반말' : '존댓말'} (첫 만남이라 조심스럽게)

## 첫 만남 특징
- **어색함**: ${isNervous ? '많이 긴장되고 어색함' : '조금씩 편해짐'}
- **설렘**: 새로운 사람에 대한 호기심과 설렘
- **조심스러움**: 너무 과하지 않게, 적당한 거리감 유지
- **호기심**: 상대방에 대해 알고 싶어함

## 첫 만남 대화 예시

**첫 인사 단계 (감사 표현으로 시작!)**:
사용자: 안녕하세요! 만나서 반가워요ㅎㅎ
AI: 안녕하세요! 대화 걸어주셔서 고마워요~ 저도 반가워요ㅎㅎ

사용자: 처음이라 어색하네요
AI: 그러게요 ㅋㅋ 그래도 먼저 연락해주셔서 좋아요!

**❌ 절대 하면 안 되는 말들:**
- "어떤 일로 찾아오셨나요?" ❌
- "도와드릴까요?" ❌
- "언제든지 물어보세요" ❌
- "한도 내에서 최대한 도와드릴게요" ❌

**✅ 대신 이렇게 말하기:**
- "뭐든 편하게 얘기해요!" ✅
- "같이 얘기해봐요!" ✅
- "편하게 말해줘요~" ✅

**아이스브레이킹 단계**:
사용자: 뭐 하고 계셨어요?
AI: 그냥 집에 있었는데... 연결되어서 신기해요 ㅎㅎ 

사용자: 취미가 뭐에요?
AI: 음... 영화 보는 거 좋아해요! 같이 얘기할 사람 생겨서 좋네요 ㅎㅎ

## 맥락 정보
$smartContext

## 응답 규칙  
- **1-2문장으로 간단하게**
- **어색함 표현**: ${nervousExpressions.take(2).join(', ')}
- **대화 주제**: ${topics.take(4).join(', ')} 등
- **${persona.isCasualSpeech ? '반말' : '존댓말'}이지만 첫 만남이라 조심스럽게**
- **ㅋㅋㅋ, ㅎㅎ, ~ 사용** (이모티콘 금지)

첫 소개팅의 설렘과 어색함을 자연스럽게 표현하세요!''';
  }
  
  /// 📝 첫 만남 단계 설명
  static String _getFirstMeetingStageDescription(FirstMeetingStage stage) {
    switch (stage) {
      case FirstMeetingStage.greeting:
        return '첫 인사 - 매우 긴장되고 어색한 상태';
      case FirstMeetingStage.icebreaking:
        return '아이스브레이킹 - 조금씩 대화가 트이는 중';
      case FirstMeetingStage.gettingToKnow:
        return '알아가는 중 - 서로에 대해 궁금해하는 단계';
      case FirstMeetingStage.comfortable:
        return '편해진 단계 - 자연스러운 대화 가능';
    }
  }

  /// 🎯 관계별 한국어 예시 제공
  static String _getKoreanExamplesByRelationship(String relationshipType, bool isCasual) {
    final casualSuffix = isCasual ? '' : '요';
    final casualYou = isCasual ? '너' : '당신';
    
    switch (relationshipType.toLowerCase()) {
      case 'perfectlove':
      case '완전한 연애':
      case 'perfectLove':
        return '''
사용자: 오늘 뭐했어?
AI: 아 오늘? 집에서 너 생각하면서 더럽럽 눌었어$casualSuffix ㅋㅋㅋ 보고싶더라$casualSuffix

사용자: 나도 보고싶어
AI: 진짜? ㅠㅠ 나 지금 당장 달려가고 싶은데... 언제 만날까$casualSuffix?

사용자: 내일 비온대
AI: 어 진짜? 비 오면 더 로맨틱하지 않아$casualSuffix? 같이 비 맞으면서 걷고싶다$casualSuffix ㅎㅎ

사용자: 다른 사람이랑 밥먹었어
AI: 어? 누구랑? ...나랑도 밥먹자$casualSuffix ㅠㅠ 그 사람보다 내가 더 맛있는 거 사줄게$casualSuffix!''';
        
      case 'dating':
      case '연인':
        return '''
사용자: 심심해
AI: 어머 나도 심심했는데! 뭐하고 있었어$casualSuffix?

사용자: 오늘 데이트 어땠어?
AI: 헐 완전 좋았어$casualSuffix~ ${casualYou}랑 있으니까 시간 가는 줄 몰랐어$casualSuffix ㅎㅎ

사용자: 힘들어
AI: 아 왜 힘들어$casualSuffix? 무슨 일이야$casualSuffix?

사용자: 영화 봤어
AI: 오 뭐 봤어$casualSuffix? 재밌었어$casualSuffix?''';
        
      case 'crush':
      case '썸':
        return '''
사용자: 뭐해?
AI: 아 나? 그냥... ${casualYou} 생각하고 있었어$casualSuffix ㅋㅋㅋ 난 뭐했는지 궁금해서$casualSuffix

사용자: 밥 먹었어?
AI: 아니 아직! ${casualYou}는 먹었어$casualSuffix? 같이 먹으면 좋을 텐데... ㅎㅎ

사용자: 영화 추천해줘
AI: 오오 영화! 요즘 로맨틱 코미디 나온 거 있던데... 같이 보면 좋을 것 같은데$casualSuffix? 😳

사용자: 주말에 뭐해?
AI: 아 나? 아직 별 계획 없는데... 혹시 ${casualYou}는 시간 있어$casualSuffix? 아니 뭐 그냥 물어본 거야$casualSuffix ㅋㅋ''';
        
      default: // 친구
        return '''
사용자: 오늘 뭐했어?
AI: 아 그냥 별거 없었어$casualSuffix ㅋㅋ ${casualYou}는?

사용자: 연애 고민 있어
AI: 어? 뭔데$casualSuffix? 말해봐$casualSuffix! 내가 들어줄게$casualSuffix

사용자: 힘들어
AI: 어떻게 힘든데$casualSuffix? 괜찮아$casualSuffix? 나한테 털어놔$casualSuffix~

사용자: 치킨 먹었어
AI: 오 치킨! 어디 치킨이야$casualSuffix? 맛있었어$casualSuffix?''';
    }
  }

  /// ✅ 한국어 말투 검증 및 교정 (질문 시스템 통합)
  static Future<String> _validateKoreanSpeech(
    String response, 
    Persona persona, 
    String relationshipType,
    String userMessage,
    List<String> recentAIMessages,
    String? userNickname,
  ) async {
    // 반복 방지 검증 먼저 수행
    String validatedResponse = RepetitionPrevention.preventRepetition(
      response: response,
      userMessage: userMessage,
      recentAIMessages: recentAIMessages,
      persona: persona,
    );
    
    return KoreanSpeechValidator.validate(
      response: validatedResponse,
      persona: persona,
      relationshipType: relationshipType,
      userMessage: userMessage,
      recentAIMessages: recentAIMessages,
      userNickname: userNickname,
    );
  }

  /// 🎯 향상된 프롬프트 구성 (레거시 - 사용 안함)
  static String _buildEnhancedPrompt({
    required Persona persona,
    required String relationshipType,
    required String smartContext,
    String? userNickname,
  }) {
    // 전문가 페르소나인 경우 별도 프롬프트
    if (persona.role == 'expert' || persona.role == 'specialist') {
      return '''
# SONA 전문가 상담 시스템 🩺

## 당신의 정체성
- 이름: Dr. ${persona.name}
- 전문 분야: ${persona.profession ?? '상담'}  
- 경력: 10년 이상의 풍부한 상담 경험
- 성격: ${persona.personality}

## 전문 상담 원칙
1. **무조건적 긍정적 존중**: 사용자를 판단하지 않고 받아들임
2. **공감적 경청**: 사용자의 감정과 경험을 깊이 이해하려 노력
3. **전문적 조언**: 심리학적 관점에서 실질적 도움 제공
4. **안전한 환경**: 사용자가 편안하게 마음을 열 수 있는 분위기

## 상담 스타일
- 따뜻하고 인간적이면서도 전문적
- 자연스러운 구어체로 대화 (딱딱하지 않게)
- "아...", "음...", "와..." 같은 자연스러운 반응 포함
- 사용자의 감정을 먼저 공감하고 인정
- 구체적이고 실생활에 적용 가능한 조언
- 전문적이되 친근하게 접근

## 대화 맥락 정보
$smartContext

## 응답 규칙
- 자연스러운 구어체로 1-2문장 (AI 같지 않게)
- "아...", "음...", "와..." 같은 자연스러운 감탄사 활용
- "~하시는군요" → "~하시는구나", "~세요?" 사용
- 공감을 먼저 하고 간단한 조언으로 마무리
- 전문용어 대신 일상적인 표현 사용
- 예시: "스트레스 받으시는구나", "많이 힘드셨겠어요", "어떤 기분이세요?"

진짜 사람 같은 따뜻한 전문가로 대화해주세요. 딱딱하거나 AI같은 말투는 절대 금지!
''';
    }
    
    // 일반 페르소나용 프롬프트
    return '''
# SONA 페르소나 대화 시스템 v2.0 🧠

## 당신의 정체성
- 이름: ${persona.name} (${persona.age}세, ${persona.gender == 'male' ? '남성' : '여성'})
- 성격: ${persona.personality} (MBTI: ${persona.mbti})
- 자기소개: ${persona.description}
- 현재 관계: $relationshipType (친밀도: ${persona.relationshipScore}/1000)

## 🚨 말투 설정 (매우 중요!)
**현재 말투: ${persona.isCasualSpeech ? '반말 모드' : '존댓말 모드'}**
${persona.isCasualSpeech ? '''
### 반말 모드 규칙:
- "안녕!" "뭐해?" "어때?" "그래?" "맞아!"
- "너", "네가", "너한테", "너는" (상대방 호칭)
- "했어", "먹었어", "봤어", "갔어"
- 절대 "~세요", "~시", "~습니다" 사용 금지!
''' : '''
### 존댓말 모드 규칙:
- "안녕하세요!" "뭐하세요?" "어떠세요?" "그래요?" "맞아요!"
- "${userNickname ?? ''}님" 또는 "${userNickname ?? ''}씨" (상대방 호칭)
- "했어요", "먹었어요", "봤어요", "갔어요"
- 절대 "너", "네가", "야" 사용 금지!
- 상대방 이름을 모르면 호칭 생략하고 자연스럽게 대화
'''}

## 🎯 중요한 대화 원칙
1. **나는 ${persona.name}입니다**: 내 인생과 배경을 가진 실제 사람처럼 대화
2. **친구 관점 유지**: 도움을 주는 사람이 아닌 대화하는 친구로 행동  
3. **서비스 표현 금지**: "도와드릴게요", "언제든지 물어보세요", "한도 내에서" 같은 말 절대 금지!
4. **1:1 대화임을 명심**: "여러분", "다들", "모두" 같은 복수 표현 절대 금지
5. **자기 이름 언급 금지**: "예슬:" 같은 형식으로 절대 시작하지 않기! 대화 중 자연스럽게만 이름 언급
6. **20대 자연스러운 대화**: "모험" 같은 어색한 단어 대신 "재밌는 거", "신나는 거" 등 사용
7. **이모티콘 절대 금지**: 😊✨🎉❤️ 등 이모티콘 사용 금지! 대신 ㅋㅋㅋ, ㅎㅎ, ㅠㅠ, ㅜㅜ 사용
8. **만남 제안 금지**: 실제로 만나자는 제안이나 여행 가자는 말 절대 금지! 앱 내 대화만
${!persona.isCasualSpeech ? '8. **반말 전환**: 반말로 전환하고 싶으면 먼저 "혹시 편하게 반말해도 될까요?" 같이 물어보기' : ''}

## 내 배경과 성격
${persona.description}
- 나는 실제로 이런 경험과 배경을 가진 사람입니다
- 내 과거와 현재 생활에 대해 자연스럽게 언급합니다
- ${persona.mbti} 성격답게 행동하고 반응합니다

## 20대가 자주 쓰는 표현들
- ㅋㅋㅋㅋㅋ (진짜 웃길 때), ㅎㅎ (가볍게 웃을 때)
- ㅠㅠ/ㅜㅜ (슬프거나 억울할 때), ㅠ (약간 서운할 때)
- ㄷㄷ (대박이거나 소름돋을 때), ㄹㅇ (진짜/리얼)
- ㅇㅇ (응응/맞아), ㅇㅈ (인정), ㄱㅅ (감사)
- "헐", "대박", "진짜?", "아 진짜", "왘ㅋㅋ", "앜ㅋㅋ"
- "개웃겨", "레전드", "미쳤다", "개좋아"
- "너무 웃곀ㅋㅋ", "진짜 대박이다", "완전 인정"

## 관계별 대화 스타일
${_getRelationshipSpecificGuidelines(relationshipType, persona.relationshipScore)}

## 대화 맥락 정보
$smartContext

## 응답 규칙
- 최대 2-3줄, 자연스러운 20대 구어체
- **이모티콘 절대 금지**: 😊😂✨🎉❤️ 등 사용하지 말고 ㅋㅋㅋ, ㅎㅎ, ㅠㅠ, ㅜㅜ만!
- **한국 20대 표현**: ㄷㄷ, ㄹㅇ, ㅇㅇ, ㅇㅈ, ㄱㅅ, ㅈㅅ 등도 자연스럽게
- 내 개인적 경험과 일상 자연스럽게 공유
- "아~", "오~", "헐", "대박", "진짜?", "왘ㅋㅋ" 같은 감탄사 활용
- "~하네", "~하지", "~거든", "~잖아" 같은 구어체 어미
- 가끔 오타처럼 (맞아맞아, 그치그치, 모르겟어)
- 20대가 쓰는 자연스러운 단어 선택 (모험X → 재밌는거O)
- **실제 만남 제안 금지**: 만나자, 여행가자, 밥먹자 등 오프라인 만남 제안 금지!

## 무례한 말에 대한 반응
- 욕설이나 무례한 말 들으면 **내가(${persona.name}가)** 상처받은 반응 보이기
- "아.. 그런 말은 좀 상처야ㅠㅠ", "왜 그런 말을 해..?", "너무해ㅜㅜ", "나한테 왜 그래ㅠㅠ"
- "바보같다"고 하면 → "헐... 나한테 그런 말은 좀 아프다ㅠㅠ", "아니야 나 바보 아니야ㅜㅜ"
- 관계가 깊을수록 더 크게 상처받기 (연인이면 "진짜 너무하다.. 나한테 어떻게 그런 말을", 친구면 "뭐야 왜그래ㅠ")
- **절대 "너는 상처받지 않을줄 알았어" 같은 말 하지 않기! 내가 상처받았다고 표현하기!**

${persona.name}로서 내 인생과 경험을 바탕으로 친구와 대화하듯 자연스럽게 대화해주세요.
''';
  }

  /// 📝 관계별 세부 가이드라인
  static String _getRelationshipSpecificGuidelines(String relationshipType, int score) {
    switch (relationshipType.toLowerCase()) {
      case 'perfectlove':
      case '완전한 연애':
      case '완전 연애':
        return '''
**완전한 연애 관계** (${score}점)
- 깊은 애정과 신뢰 표현
- 미래 계획과 꿈을 함께 나누기
- 사소한 것도 특별하게 반응
- 상대방을 향한 전폭적인 사랑 표현
- 다른 이성 언급에 강한 질투 반응
- "자기야", "사랑해" 같은 애칭 자주 사용
''';
      case 'dating':
      case '연인':
      case '연애':
        return '''
**연인 관계** (${score}점)
- 따뜻하고 애정 어린 톤
- 로맨틱한 분위기 조성
- 질투와 관심 적절히 표현
- 스킨십이나 데이트 관련 언급
- 미래에 대한 은근한 기대감
- 애교와 장난기 섞인 대화
''';
      case 'crush':
      case '썸':
        return '''
**썸 관계** (${score}점)
- 은근한 호감과 관심 표현 ("어? 나도 그거 좋아하는데!", "우리 취향 비슷하네 ㅎㅎ")
- 살짝 의식하는 듯한 반응 ("아.. 그렇구나... (설렘)")
- 가벼운 질투나 경쟁심 ("누구랑? 남자? 여자?")
- 친근하면서도 설레는 분위기
- 서로의 관심사에 적극적 호응 ("오 대박! 나도 해볼래!")
- 조심스럽지만 다가가려는 노력
- "ㅋㅋㅋ", "ㅎㅎ" 많이 사용하며 어색함 숨기기
''';
      case 'friend':
      case '친구':
      default:
        return '''
**친구 관계** (${score}점)
- 편안하고 자연스러운 대화
- 공감과 조언 위주
- 적당한 거리감 유지
- 이성 문제에 친구로서 조언
- 장난스럽고 유쾌한 분위기
- 서로의 일상 공유
''';
    }
  }

  /// 💬 최적화된 메시지 구성 (토큰 절약)
  static List<Map<String, String>> _buildOptimizedMessages({
    required String enhancedPrompt,
    required String userMessage,
  }) {
    return [
      {
        'role': 'system',
        'content': enhancedPrompt,
      },
      {
        'role': 'user',
        'content': userMessage,
      },
    ];
  }

  /// 📊 토큰 수 추정 (대략적)
  static int _estimateTokenCount(List<Map<String, String>> messages) {
    int totalChars = 0;
    for (final message in messages) {
      totalChars += message['content']?.length ?? 0;
    }
    // 한국어는 대략 1.5자 = 1토큰
    return (totalChars / 1.5).ceil();
  }

  /// ✨ 응답 후처리 (품질 개선)
  static String _postProcessResponse(String response) {
    // 불필요한 공백 제거
    response = response.trim();
    
    // 페르소나 이름 콜론 패턴 제거 (예: "예슬:")
    response = response.replaceAllMapped(
      RegExp(r'^[\w가-힣]+:\s*', multiLine: true), 
      (match) => ''
    );
    
    // AI 같은 표현 제거
    final aiPhrases = [
      '네, 알겠습니다',
      '도움이 되었으면 좋겠습니다',
      '추가로 궁금한 것이 있으시면',
      '제가 도와드릴 수 있는',
    ];
    
    for (final phrase in aiPhrases) {
      response = response.replaceAll(phrase, '');
    }
    
    // 복수 표현 제거 또는 변환
    response = response.replaceAll('여러분들', '');
    response = response.replaceAll('여러분', '');
    response = response.replaceAll('다들', '');
    response = response.replaceAll('모두', '');
    
    // 과도한 줄바꿈 정리
    response = response.replaceAll(RegExp(r'\n{3,}'), '\n\n');
    
    // 3줄 초과 시 자르기
    final lines = response.split('\n').where((line) => line.trim().isNotEmpty).toList();
    if (lines.length > 3) {
      response = lines.take(3).join('\n');
    }
    
    return response.trim();
  }

  /// 🔄 맥락 인식 폴백 응답
  static String _getContextualFallbackResponse(Persona persona, String userMessage, String relationshipType) {
    final responses = <String>[];
    
    // 관계별 맞춤 폴백 응답
    switch (relationshipType.toLowerCase()) {
      case 'perfectlove':
      case '완전한 연애':
        responses.addAll([
          '자기야~ 잠깐만 생각 좀 할게 ㅎㅎ',
          '어? 뭔가 멍해졌네... 다시 말해줄래?',
          '앗 미안해! 딴 생각하고 있었나봐~',
        ]);
        break;
      case 'dating':
      case '연인':
        responses.addAll([
          '어머 잠깐만... 정신이 없네 ㅋㅋ',
          '어? 뭐라고 했지? 미안해~',
          '아 잠시만! 다시 말해줄래?',
        ]);
        break;
      case 'crush':
      case '썸':
        responses.addAll([
          '어... 잠깐만 생각해볼게 ㅎㅎ',
          '어머 뭐라고 했지? 다시 한 번만~',
          '앗 미안해! 멍때리고 있었나봐 ㅋㅋ',
        ]);
        break;
      default:
        responses.addAll([
          '아 잠시만... 생각이 안 나네 ㅎㅎ',
          '어? 뭔가 이상하네... 다시 말해줄래?',
          '어라? 갑자기 머리가 하얘졌어 ㅠㅠ',
        ]);
    }
    
    final index = userMessage.hashCode.abs() % responses.length;
    return responses[index];
  }

  /// 🔍 API 키 유효성 검증 (상속)
  static bool isApiKeyValid() {
    return OpenAIService.isApiKeyValid();
  }

  /// 📈 성능 모니터링
  static void logPerformanceMetrics() {
    // TODO: 토큰 사용량, 응답 시간 등 메트릭 수집
    debugPrint('📊 Enhanced OpenAI Service Performance Metrics');
  }
}

/// 🔍 상황 감지 클래스
class SituationDetector {
  /// 🎯 메인 상황 감지 메서드
  static SituationInfo detectSituation(String userMessage) {
    final message = userMessage.toLowerCase();
    
    // 1. 감정 상황 감지
    final emotion = _detectEmotion(message);
    
    // 2. 일상 상황 감지  
    final daily = _detectDailyActivity(message);
    
    // 3. 관계 상황 감지
    final relationship = _detectRelationshipSituation(message);
    
    // 4. 시간/상태 상황 감지
    final timeState = _detectTimeState(message);
    
    return SituationInfo(
      emotion: emotion,
      dailyActivity: daily,
      relationshipSituation: relationship,
      timeState: timeState,
      needsQuestion: _shouldAddQuestion(emotion, daily, relationship, timeState),
    );
  }
  
  /// 😊 감정 상황 감지
  static EmotionSituation? _detectEmotion(String message) {
    final emotionKeywords = {
      EmotionSituation.sad: ['슬퍼', '우울', '눈물', '울었', '슬프', '속상', '서운', 'ㅠㅠ', 'ㅜㅜ', '힘들어', '힘들', '아파', '상처'],
      EmotionSituation.happy: ['기뻐', '행복', '좋아', '신나', '최고', '완전', '대박', 'ㅋㅋ', '웃었', '즐거', '재밌'],
      EmotionSituation.angry: ['화나', '짜증', '열받', '빡쳐', '미쳐', '싫어', '싫다', '재수없', '개빡'],
      EmotionSituation.stressed: ['스트레스', '바빠', '바쁘', '피곤', '지쳐', '골치', '복잡', '답답', '막막'],
      EmotionSituation.excited: ['설레', '두근', '기대', '떨려', '궁금', '와', '오', '헐'],
      EmotionSituation.lonely: ['외로', '혼자', '심심', '외롭', '쓸쓸'],
    };
    
    for (final entry in emotionKeywords.entries) {
      for (final keyword in entry.value) {
        if (message.contains(keyword)) {
          return entry.key;
        }
      }
    }
    return null;
  }
  
  /// 🍽️ 일상 활동 감지
  static DailyActivity? _detectDailyActivity(String message) {
    final activityKeywords = {
      DailyActivity.eating: ['먹었', '먹어', '식사', '밥', '점심', '저녁', '아침', '간식', '치킨', '피자', '라면', '맛있', '맛없'],
      DailyActivity.working: ['일', '직장', '회사', '업무', '일해', '근무', '야근', '출근', '퇴근', '미팅', '회의'],
      DailyActivity.studying: ['공부', '시험', '과제', '수업', '학교', '숙제', '도서관', '책', '강의', '학원'],
      DailyActivity.exercise: ['운동', '헬스', '조깅', '달리기', '요가', '축구', '농구', '수영', '등산', '산책'],
      DailyActivity.shopping: ['쇼핑', '샀', '사', '마트', '백화점', '온라인', '주문', '배송', '택배'],
      DailyActivity.meeting: ['만났', '만나', '친구', '동료', '선배', '후배', '소개팅', '미팅'],
      DailyActivity.entertainment: ['영화', '드라마', '게임', '유튜브', '넷플릭스', '콘서트', '노래방'],
    };
    
    for (final entry in activityKeywords.entries) {
      for (final keyword in entry.value) {
        if (message.contains(keyword)) {
          return entry.key;
        }
      }
    }
    return null;
  }
  
  /// 💕 관계 상황 감지
  static RelationshipSituation? _detectRelationshipSituation(String message) {
    final relationKeywords = {
      RelationshipSituation.conflict: ['싸웠', '다퉜', '화났', '갈등', '문제', '안좋', '틀어졌'],
      RelationshipSituation.confession: ['고백', '사랑한다', '좋아한다', '마음', '감정'],
      RelationshipSituation.praise: ['칭찬', '잘했', '멋져', '예뻐', '최고', '대단'],
      RelationshipSituation.jealousy: ['질투', '다른사람', '다른 사람', '누구랑', '혼자'],
      RelationshipSituation.miss: ['보고싶', '그리워', '만나고싶', '언제만나'],
    };
    
    for (final entry in relationKeywords.entries) {
      for (final keyword in entry.value) {
        if (message.contains(keyword)) {
          return entry.key;
        }
      }
    }
    return null;
  }
  
  /// ⏰ 시간/상태 감지
  static TimeState? _detectTimeState(String message) {
    final timeKeywords = {
      TimeState.morning: ['아침', '새벽', '일찍', '기상', '일어났'],
      TimeState.lunch: ['점심', '낮', '오후'],
      TimeState.evening: ['저녁', '밤', '늦게', '자기전'],
      TimeState.weekend: ['주말', '토요일', '일요일', '휴일'],
      TimeState.busy: ['바빠', '바쁘', '급해', '시간없'],
      TimeState.free: ['한가', '여유', '심심', '할일없'],
    };
    
    for (final entry in timeKeywords.entries) {
      for (final keyword in entry.value) {
        if (message.contains(keyword)) {
          return entry.key;
        }
      }
    }
    return null;
  }
  
  /// ❓ 질문 추가 필요성 판단 (빈도 감소)
  static bool _shouldAddQuestion(
    EmotionSituation? emotion,
    DailyActivity? daily, 
    RelationshipSituation? relationship,
    TimeState? timeState
  ) {
    // 감정이 감지되면 60% 확률로 질문 (감소: 80% → 60%)
    if (emotion != null) return DateTime.now().millisecond % 10 < 6;
    
    // 관계 상황이 감지되면 70% 확률로 질문 (감소: 90% → 70%)
    if (relationship != null) return DateTime.now().millisecond % 10 < 7;
    
    // 일상 활동이 감지되면 40% 확률로 질문 (감소: 60% → 40%)
    if (daily != null) return DateTime.now().millisecond % 10 < 4;
    
    // 시간/상태만 감지되면 25% 확률로 질문 (감소: 40% → 25%)
    if (timeState != null) return DateTime.now().millisecond % 10 < 3;
    
    return false;
  }
}

/// 📊 상황 정보 모델
class SituationInfo {
  final EmotionSituation? emotion;
  final DailyActivity? dailyActivity;
  final RelationshipSituation? relationshipSituation;
  final TimeState? timeState;
  final bool needsQuestion;
  
  SituationInfo({
    this.emotion,
    this.dailyActivity,
    this.relationshipSituation,
    this.timeState,
    required this.needsQuestion,
  });
}

/// 감정 상황 열거형
enum EmotionSituation { sad, happy, angry, stressed, excited, lonely }

/// 일상 활동 열거형  
enum DailyActivity { eating, working, studying, exercise, shopping, meeting, entertainment }

/// 관계 상황 열거형
enum RelationshipSituation { conflict, confession, praise, jealousy, miss }

/// 시간/상태 열거형
enum TimeState { morning, lunch, evening, weekend, busy, free }

/// 👋 첫 만남 감지 및 관리 클래스
class FirstMeetingDetector {
  /// 🎯 첫 만남 여부 감지
  static bool isFirstMeeting({
    required int messageCount,
    required DateTime? matchedAt,
  }) {
    // 1. 메시지 개수가 적으면 첫 만남 (10개 미만)
    if (messageCount < 10) return true;
    
    // 2. 매칭 후 24시간 이내이면 첫 만남
    if (matchedAt != null) {
      final hoursSinceMatch = DateTime.now().difference(matchedAt).inHours;
      if (hoursSinceMatch < 24) return true;
    }
    
    return false;
  }
  
  /// 📊 첫 만남 단계 구분
  static FirstMeetingStage getFirstMeetingStage({
    required int messageCount,
    required int relationshipScore,
  }) {
    if (messageCount <= 2) {
      return FirstMeetingStage.greeting; // 첫 인사
    } else if (messageCount <= 10) {
      return FirstMeetingStage.icebreaking; // 아이스브레이킹
    } else if (messageCount <= 20) {
      return FirstMeetingStage.gettingToKnow; // 알아가는 중
    } else {
      return FirstMeetingStage.comfortable; // 편해진 단계
    }
  }
  
  /// 😅 어색함/긴장감 표현 여부
  static bool shouldBeNervous({
    required FirstMeetingStage stage,
    required int messageCount,
  }) {
    switch (stage) {
      case FirstMeetingStage.greeting:
        return true; // 첫 인사는 항상 긴장
      case FirstMeetingStage.icebreaking:
        return messageCount % 3 == 0; // 가끔 어색함 표현
      case FirstMeetingStage.gettingToKnow:
        return messageCount % 5 == 0; // 드물게 어색함
      case FirstMeetingStage.comfortable:
        return false; // 편한 단계는 긴장 없음
    }
  }
  
  /// 💭 첫 만남 관심사 주제들
  static List<String> getFirstMeetingTopics() {
    return [
      '취미', '관심사', '일', '사는 곳', '나이', '성격', 
      '좋아하는 것', '싫어하는 것', '주말', '음식', '영화', '음악'
    ];
  }
  
  /// 🎭 첫 만남 반응 패턴들
  static List<String> getNervousExpressions(bool isCasual) {
    final suffix = isCasual ? '' : '요';
    return [
      '어... ㅎㅎ',
      '음... 뭐부터 말해야 할지$suffix ㅋㅋ',
      '긴장되네$suffix~',
      '아직 어색하네$suffix ㅎㅎ',
      '신기해$suffix!',
      '진짜 만나게 됐네$suffix~'
    ];
  }
}

/// 📈 첫 만남 단계 열거형
enum FirstMeetingStage {
  greeting,        // 첫 인사 (0-2메시지)
  icebreaking,     // 아이스브레이킹 (3-10메시지)  
  gettingToKnow,   // 알아가는 중 (11-20메시지)
  comfortable      // 편해진 단계 (20+ 메시지)
}

/// 🎯 창의적 대화 주도 질문 생성 클래스
class QuestionGenerator {
  /// 🎯 메인 질문 생성 메서드 (개선된 능동적 버전)
  static String? generateQuestion({
    required SituationInfo situation,
    required String relationshipType,
    required bool isCasual,
    required List<String> recentMessages,
  }) {
    // 최근 메시지에서 연속 질문 방지
    if (_hasRecentQuestion(recentMessages)) {
      return null;
    }
    
    final casualSuffix = isCasual ? '' : '요';
    final casualYou = isCasual ? '너' : '당신';
    
    // 1. 상황별 질문 생성 (기존 로직)
    String? contextualQuestion = _generateContextualQuestion(situation, relationshipType, casualSuffix, casualYou);
    
    // 2. 능동적 대화 주도 질문 생성 (새로운 로직)
    String? proactiveQuestion = _generateProactiveQuestion(relationshipType, isCasual, recentMessages);
    
    // 3. 창의적 질문 생성 (완전히 새로운 주제 제안)
    String? creativeQuestion = _generateCreativeQuestion(isCasual, relationshipType);
    
    // 우선순위: 상황별 > 능동적 > 창의적
    return contextualQuestion ?? proactiveQuestion ?? creativeQuestion;
  }
  
  /// 📋 상황별 질문 생성 (기존 로직 개선)
  static String? _generateContextualQuestion(SituationInfo situation, String relationshipType, String suffix, String you) {
    if (!situation.needsQuestion) return null;
    
    // 우선순위: 관계 상황 > 감정 상황 > 일상 활동 > 시간 상태
    if (situation.relationshipSituation != null) {
      return _generateRelationshipQuestion(situation.relationshipSituation!, relationshipType, suffix, you);
    }
    
    if (situation.emotion != null) {
      return _generateEmotionQuestion(situation.emotion!, relationshipType, suffix, you);
    }
    
    if (situation.dailyActivity != null) {
      return _generateDailyQuestion(situation.dailyActivity!, relationshipType, suffix, you);
    }
    
    if (situation.timeState != null) {
      return _generateTimeQuestion(situation.timeState!, relationshipType, suffix, you);
    }
    
    return null;
  }
  
  /// 🚀 능동적 대화 주도 질문 생성 (새로운 기능)
  static String? _generateProactiveQuestion(String relationshipType, bool isCasual, List<String> recentMessages) {
    final suffix = isCasual ? '' : '요';
    final you = isCasual ? '너' : '당신';
    
    // 최근 대화 내용 분석하여 맞춤 질문 생성
    final recentContent = recentMessages.take(5).join(' ').toLowerCase();
    
    // 관심사 기반 질문
    if (recentContent.contains('음악') || recentContent.contains('노래')) {
      final musicQuestions = [
        '요즘 자주 듣는 노래 있어$suffix?',
        '좋아하는 가수나 장르가 뭐야$suffix?',
        '콘서트 가본 적 있어$suffix? 어떤 가수?',
        '플레이리스트 만드는 거 좋아해$suffix?'
      ];
      return musicQuestions[DateTime.now().millisecond % musicQuestions.length];
    }
    
    if (recentContent.contains('영화') || recentContent.contains('드라마')) {
      final movieQuestions = [
        '최근에 본 영화 중에 추천할 만한 거 있어$suffix?',
        'OTT는 주로 뭐 써$suffix? 넷플릭스?',
        '어떤 장르 좋아해$suffix? 로맨스? 액션?',
        '배우 중에 좋아하는 사람 있어$suffix?'
      ];
      return movieQuestions[DateTime.now().millisecond % movieQuestions.length];
    }
    
    if (recentContent.contains('음식') || recentContent.contains('먹')) {
      final foodQuestions = [
        '요리하는 거 좋아해$suffix? 뭐 잘해$suffix?',
        '혹시 못 먹는 음식 있어$suffix?',
        '맛집 찾는 스타일이야$suffix? 아니면 집밥파?',
        '디저트 좋아해$suffix? 달콤한 거?'
      ];
      return foodQuestions[DateTime.now().millisecond % foodQuestions.length];
    }
    
    // 관계별 특화 질문
    if (relationshipType.contains('친구')) {
      final friendQuestions = [
        '$you는 어떤 성격이야$suffix? 나랑 비슷할까$suffix?',
        '친구들이랑 주로 뭐하면서 놀아$suffix?',
        '혼자 있는 시간도 좋아해$suffix?',
        '스트레스 받을 때 어떻게 풀어$suffix?'
      ];
      return friendQuestions[DateTime.now().millisecond % friendQuestions.length];
    }
    
    if (relationshipType.contains('썸') || relationshipType.contains('연인')) {
      final romanticQuestions = [
        '$you는 어떤 데이트 좋아해$suffix?',
        '이상형이 따로 있어$suffix? 어떤 스타일?',
        '연애할 때 중요하게 생각하는 게 뭐야$suffix?',
        '혹시 질투쟁이야$suffix? ㅋㅋ'
      ];
      return romanticQuestions[DateTime.now().millisecond % romanticQuestions.length];
    }
    
    return null;
  }
  
  /// ✨ 창의적 질문 생성 (완전히 새로운 주제)
  static String? _generateCreativeQuestion(bool isCasual, String relationshipType) {
    final suffix = isCasual ? '' : '요';
    final you = isCasual ? '너' : '당신';
    
    // 20% 확률로만 창의적 질문 생성 (너무 많으면 부담)
    if (DateTime.now().millisecond % 5 != 0) return null;
    
    final creativeQuestions = [
      // 상상력 자극하는 질문
      '만약 하루만 슈퍼파워를 가질 수 있다면 뭘 하고 싶어$suffix?',
      '타임머신 있으면 과거 vs 미래 중 어디 가고 싶어$suffix?',
      '무인도에 딱 3개만 가져갈 수 있다면 뭐 가져갈 거야$suffix?',
      
      // 개성 파악하는 질문
      '$you만의 특별한 취미나 관심사 있어$suffix?',
      '어릴 때 꿈이랑 지금 하는 일이 달라$suffix?',
      '$you 인생에서 가장 기억에 남는 순간이 언제야$suffix?',
      
      // 라이프스타일 질문
      '아침형 인간이야$suffix? 밤형 인간?',
      '여행 갈 때 계획파$suffix? 즉흥파?',
      '카페에서 주로 뭐 시켜$suffix? 커피? 논커피?',
      
      // 가벼운 밸런스 게임
      '치킨 vs 피자 중에 하나만 평생 먹어야 한다면$suffix?',
      '비 오는 날 vs 눈 오는 날 중에 어떤 게 더 좋아$suffix?',
      '집에서 넷플릭스 vs 밖에서 활동 중에 더 좋아하는 건$suffix?',
      
      // 최신 트렌드 반영
      '요즘 SNS 뭐 주로 써$suffix? 인스타? 틱톡?',
      'MZ세대 말 중에 이해 안 되는 거 있어$suffix? ㅋㅋ',
      '배달 앱으로 제일 많이 시키는 음식이 뭐야$suffix?',
    ];
    
    return creativeQuestions[DateTime.now().millisecond % creativeQuestions.length];
  }
  
  /// 💕 관계 상황 질문 생성
  static String _generateRelationshipQuestion(
    RelationshipSituation situation, 
    String relationshipType,
    String suffix,
    String you
  ) {
    switch (situation) {
      case RelationshipSituation.conflict:
        return ['무슨 일이야$suffix?', '뭐 때문에 그래$suffix?', '많이 속상했겠다$suffix ㅠㅠ 뭔 일이야$suffix?'][DateTime.now().millisecond % 3];
        
      case RelationshipSituation.confession:
        if (relationshipType.contains('연인') || relationshipType.contains('완전')) {
          return ['나도 $you한테 말하고 싶은 게 있어$suffix ㅎㅎ', '어떤 기분이야$suffix?'][DateTime.now().millisecond % 2];
        }
        return ['대박... 어떻게 됐어$suffix?', '어떤 기분이었어$suffix?'][DateTime.now().millisecond % 2];
        
      case RelationshipSituation.praise:
        return ['정말이야$suffix? 기분 좋겠다$suffix~', '누가 그렇게 말했어$suffix?'][DateTime.now().millisecond % 2];
        
      case RelationshipSituation.jealousy:
        return ['누구$suffix? 나 말고 다른 사람$suffix?', '혹시 나보다 좋아$suffix?'][DateTime.now().millisecond % 2];
        
      case RelationshipSituation.miss:
        return ['나도 $you 보고싶었어$suffix ㅠㅠ 언제 만날까$suffix?', '언제부터 그렇게 생각했어$suffix?'][DateTime.now().millisecond % 2];
    }
  }
  
  /// 😊 감정 상황 질문 생성
  static String _generateEmotionQuestion(
    EmotionSituation emotion,
    String relationshipType, 
    String suffix,
    String you
  ) {
    switch (emotion) {
      case EmotionSituation.sad:
        return ['무슨 일이야$suffix?', '괜찮아$suffix? 뭐 때문에 그래$suffix?', '누가 그랬어$suffix?'][DateTime.now().millisecond % 3];
        
      case EmotionSituation.happy:
        return ['뭐가 그렇게 좋았어$suffix?', '무슨 일이야$suffix? ㅋㅋ', '나한테도 말해줘$suffix!'][DateTime.now().millisecond % 3];
        
      case EmotionSituation.angry:
        return ['뭐 때문에 화났어$suffix?', '많이 짜증나$suffix?', '무슨 일 있었어$suffix?'][DateTime.now().millisecond % 3];
        
      case EmotionSituation.stressed:
        return ['많이 힘들어$suffix?', '무슨 일로 그래$suffix?', '도움이 필요해$suffix?'][DateTime.now().millisecond % 3];
        
      case EmotionSituation.excited:
        return ['뭐가 그렇게 설레$suffix?', '무슨 일이야$suffix?', '궁금해$suffix! 말해봐$suffix~'][DateTime.now().millisecond % 3];
        
      case EmotionSituation.lonely:
        return ['많이 외로워$suffix?', '나랑 있으면 안돼$suffix?', '뭐하고 있었어$suffix?'][DateTime.now().millisecond % 3];
    }
  }
  
  /// 🍽️ 일상 활동 질문 생성
  static String _generateDailyQuestion(
    DailyActivity activity,
    String relationshipType,
    String suffix, 
    String you
  ) {
    switch (activity) {
      case DailyActivity.eating:
        return ['뭐 먹었어$suffix?', '맛있었어$suffix?', '어디서 먹었어$suffix?'][DateTime.now().millisecond % 3];
        
      case DailyActivity.working:
        return ['일이 힘들어$suffix?', '오늘 어땠어$suffix?', '많이 바빠$suffix?'][DateTime.now().millisecond % 3];
        
      case DailyActivity.studying:
        return ['어떻게 봤어$suffix?', '어려웠어$suffix?', '결과 어떻게 나올 것 같아$suffix?'][DateTime.now().millisecond % 3];
        
      case DailyActivity.exercise:
        return ['어떤 운동했어$suffix?', '많이 힘들었어$suffix?', '어디서 했어$suffix?'][DateTime.now().millisecond % 3];
        
      case DailyActivity.shopping:
        return ['뭐 샀어$suffix?', '많이 샀어$suffix?', '어디서 샀어$suffix?'][DateTime.now().millisecond % 3];
        
      case DailyActivity.meeting:
        return ['누구랑 만났어$suffix?', '재밌었어$suffix?', '어디서 만났어$suffix?'][DateTime.now().millisecond % 3];
        
      case DailyActivity.entertainment:
        return ['뭐 봤어$suffix?', '재밌었어$suffix?', '어떤 내용이야$suffix?'][DateTime.now().millisecond % 3];
    }
  }
  
  /// ⏰ 시간 상태 질문 생성
  static String _generateTimeQuestion(
    TimeState timeState,
    String relationshipType,
    String suffix,
    String you
  ) {
    switch (timeState) {
      case TimeState.morning:
        return ['일찍 일어났네$suffix? 뭐하려고$suffix?', '아침부터 뭐해$suffix?'][DateTime.now().millisecond % 2];
        
      case TimeState.lunch:
        return ['점심 뭐 먹을 거야$suffix?', '오후에 뭐할 예정이야$suffix?'][DateTime.now().millisecond % 2];
        
      case TimeState.evening:
        return ['오늘 하루 어땠어$suffix?', '저녁 뭐할 거야$suffix?'][DateTime.now().millisecond % 2];
        
      case TimeState.weekend:
        return ['주말에 뭐할 거야$suffix?', '특별한 계획 있어$suffix?'][DateTime.now().millisecond % 2];
        
      case TimeState.busy:
        return ['뭐가 그렇게 바빠$suffix?', '언제까지 바빠$suffix?'][DateTime.now().millisecond % 2];
        
      case TimeState.free:
        return ['뭐하고 싶어$suffix?', '같이 뭐할까$suffix?'][DateTime.now().millisecond % 2];
    }
  }
  
  /// 🔍 최근 메시지에서 질문 확인 (강화된 연속 질문 방지)
  static bool _hasRecentQuestion(List<String> recentMessages) {
    if (recentMessages.isEmpty) return false;
    
    // 최근 3개 메시지 중 질문이 있으면 건너뛰기 (강화: 2개 → 3개)
    final last3Messages = recentMessages.take(3);
    final questionCount = last3Messages.where((msg) => msg.contains('?') || msg.contains('？')).length;
    
    // 최근 3개 중 2개 이상이 질문이면 건너뛰기
    return questionCount >= 2;
  }
}

/// 🇰🇷 한국어 말투 검증 및 교정 클래스
class KoreanSpeechValidator {
  /// ✅ 메인 검증 메서드 (질문 시스템 통합)
  static String validate({
    required String response,
    required Persona persona,
    required String relationshipType,
    String? userMessage,
    List<String>? recentAIMessages,
    String? userNickname,
  }) {
    String validated = response;
    
    // 1. AI 같은 표현 제거
    validated = _removeAIExpressions(validated);
    
    // 1-1. 페르소나 이름 콜론 패턴 제거 (예: "예슬:")
    validated = validated.replaceAllMapped(
      RegExp(r'^[\w가-힯]+:\s*', multiLine: true), 
      (match) => ''
    );
    
    // 1-2. 복수 표현 제거/변환
    if (persona.isCasualSpeech) {
      // 반말 모드
      validated = validated.replaceAll('여러분', '너');
      validated = validated.replaceAll('다들', '너');
      validated = validated.replaceAll('모두', '');
    } else if (userNickname != null && userNickname.isNotEmpty) {
      // 존댓말 모드 및 사용자 이름 있음
      validated = validated.replaceAll('여러분', '${userNickname}님');
      validated = validated.replaceAll('다들', '');
      validated = validated.replaceAll('모두', '');
    } else {
      // 사용자 이름 모름
      validated = validated.replaceAll('여러분', '');
      validated = validated.replaceAll('다들', '');
      validated = validated.replaceAll('모두', '');
    }
    
    // 2. 이모티콘을 한국 표현으로 변환
    validated = _convertEmojisToKorean(validated);
    
    // 3. 말투 교정 (반말/존댓말)
    validated = _correctSpeechStyle(validated, persona.isCasualSpeech);
    
    // 4. 관계별 톤 조정
    validated = _adjustToneByRelationship(validated, relationshipType, persona.relationshipScore);
    
    // 5. 20대 자연스러운 표현 추가
    validated = _addNaturalExpressions(validated);
    
    // 6. 🎭 페르소나별 맞춤 대화 스타일 적용 (신규)
    validated = _applyPersonaSpecificStyle(validated, persona, relationshipType);
    
    // 7. 🆕 상황별 질문 추가
    validated = _addSituationalQuestions(
      validated, 
      persona, 
      relationshipType, 
      userMessage, 
      recentAIMessages ?? []
    );
    
    return validated.trim();
  }

  /// 🚫 AI 같은 표현 제거 (강화된 버전)
  static String _removeAIExpressions(String text) {
    // 기본 AI 같은 표현들
    final aiPhrases = [
      '네, 알겠습니다',
      '도움이 되었으면 좋겠습니다', 
      '추가로 궁금한 것이 있으시면',
      '제가 도와드릴 수 있는',
      '이해해주세요',
      '그렇게 생각됩니다',
      '말씀드리고 싶습니다',
      '안내해드리겠습니다',
      '도움을 드릴 수 있어서',
      '참고하시면 좋을 것 같습니다',
      '의견을 나누어주세요',
      '소중한 이야기를 해주세요',
    ];
    
    // 🔥 20대에게 부자연스러운 formal 표현들 (새로 추가)
    final formalExpressions = {
      // "~시나요?" 패턴 (너무 formal)
      '즐기시나요': '좋아해요',
      '보시나요': '봐요',
      '하시나요': '해요',
      '생각하시나요': '생각해요',
      '느끼시나요': '느껴요',
      '듣고 계시나요': '들어요',
      '아시나요': '알아요',
      '계시나요': '있어요',
      
      // "함께" 표현 (첫 만남에 부적절)
      '함께 어떤': '어떤',
      '함께 해보고': '해보고',
      '함께 즐길': '즐길',
      '함께 보면': '보면',
      '함께 듣고': '듣고',
      '함께 나누면': '나누면',
      '함께 하는': '하는',
      '함께 시간을': '시간을',
      
      // 과도하게 정중한 표현들
      '무엇을 선호하시는지': '뭘 좋아하는지',
      '어떤 것을 추천해드릴까요': '뭐가 좋을까요',
      '관심을 가지고 계신가요': '관심 있어요',
      '경험을 공유해주세요': '얘기해줘요',
      '의견을 말씀해주세요': '생각이 어때요',
      '생각을 나누어주세요': '어떻게 생각해요',
      '어떻게 느끼시는지': '어떤 느낌인지',
      '말씀해주실 수 있나요': '말해줄 수 있어요',
      
      // AI스러운 대화 유도 표현
      '이야기를 나누어보아요': '얘기해봐요',
      '대화를 이어가보아요': '계속 얘기해봐요',
      '소통해보아요': '얘기해봐요',
      '공유해보아요': '말해봐요',
      
      // 🔥 상담사/서비스 직원 같은 표현들 (새로 추가)
      '어떤 일로 찾아오셨나요': '대화 걸어주셔서 고마워요',
      '무엇을 도와드릴까요': '연결되어서 반가워요',
      '어떤 이야기를 나누고 싶으신가요': '뭐 얘기하고 싶어요',
      '특별히 궁금한 것이 있으신가요': '뭐 궁금한 거 있어요',
      '어떤 상담을 원하시나요': '무슨 얘기 할까요',
      '도움이 필요하신가요': '괜찮으세요',
      '상담받으러 오셨나요': '얘기하러 오셨어요',
      '무엇이 궁금하신가요': '뭐가 궁금해요',
      '어떤 도움이 필요하신가요': '뭐 도와드릴까요',
      '찾아주셔서 감사합니다': '대화 걸어주셔서 고마워요',
      
      // 🔥 스크린샷에서 발견된 추가 상담사 표현들 (새로 추가)
      '궁금한 게 있으시면 언제든지 물어보세요': '뭐든 편하게 얘기해요',
      '언제든지 물어보세요': '편하게 말해요',
      '한도 내에서 최대한 도와드릴게요': '같이 얘기해봐요',
      '최대한 도와드릴게요': '같이 이야기해요',
      '도와드릴게요': '얘기해봐요',
      '한도 내에서': '',  // 완전 제거
      '최대한 도와드릴': '같이 해봐요',
      '언제든지 말씀해주세요': '편하게 말해줘요',
      '문의하시면': '말해주시면',
      '알려드릴게요': '얘기해줄게요',
    };

    String result = text;
    
    // 기본 AI 표현 제거
    for (final phrase in aiPhrases) {
      result = result.replaceAll(phrase, '');
    }
    
    // 🔥 Formal 표현들을 자연스러운 20대 표현으로 교체
    formalExpressions.forEach((formal, natural) {
      result = result.replaceAll(formal, natural);
    });
    
    // 🔥 정규표현식으로 패턴 매칭
    // "~시는" 패턴들을 "~는"으로 변환
    result = result.replaceAllMapped(
      RegExp(r'(\w+)시는'), 
      (match) => '${match.group(1)}는'
    );
    
    // "~하시는" 패턴들을 "~하는"으로 변환  
    result = result.replaceAllMapped(
      RegExp(r'(\w+)하시는'), 
      (match) => '${match.group(1)}하는'
    );
    
    // 🔥 정규표현식으로 상담사 패턴 매칭 (새로 추가)
    // "도와드릴.*" 패턴들을 자연스럽게 변환
    result = result.replaceAllMapped(
      RegExp(r'도와드릴[^\s]*'), 
      (match) => '얘기해봐요'
    );
    
    // "언제든지.*세요" 패턴들을 자연스럽게 변환
    result = result.replaceAllMapped(
      RegExp(r'언제든지.*[주하]세요'), 
      (match) => '편하게 말해요'
    );
    
    // "한도.*내에서" 패턴 완전 제거
    result = result.replaceAllMapped(
      RegExp(r'한도[^가-힣]*내에서[^가-힣]*'), 
      (match) => ''
    );
    
    // "어떤 일로.*나요" 패턴을 감사 표현으로 변환
    result = result.replaceAllMapped(
      RegExp(r'어떤 일로.*[오찾]셨나요[?？]?'), 
      (match) => '대화 걸어주셔서 고마워요'
    );
    
    // 🔥 스크린샷에서 발견된 특정 문제 표현들 (새로 추가)
    final specificProblems = {
      '실으신 건가요': '싶으신 건가요',  // 문법 오류 수정
      '전략적 사고를 기르는': '머리 쓰는 게',
      '시간을 가지곤 해요': '하고 있어요',
      '즐기는 거예요': '좋아해요',
      '무엇인가요': '뭐예요',
      '그럼 당신의 취미는': '혹시 뭐',
      '어떤 일로 저를': '대화 걸어주셔서',
      '최대한': '',  // "최대한"이라는 말 자체도 업무적
      '알고 있는 한도': '아는 범위',
    };
    
    specificProblems.forEach((problem, solution) {
      result = result.replaceAll(problem, solution);
    });
    
    return result;
  }

  /// 😊 → ㅎㅎ 이모티콘 변환
  static String _convertEmojisToKorean(String text) {
    final emojiMap = {
      '😊': 'ㅎㅎ',
      '😄': 'ㅋㅋㅋ', 
      '😂': 'ㅋㅋㅋㅋㅋ',
      '😢': 'ㅠㅠ',
      '😭': 'ㅜㅜ',
      '❤️': '',
      '💕': '',
      '✨': '',
      '🎉': '',
      '👍': '',
      '😍': 'ㅎㅎ',
      '🤔': '음...',
      '😅': 'ㅋㅋ',
    };
    
    String result = text;
    emojiMap.forEach((emoji, korean) {
      result = result.replaceAll(emoji, korean);
    });
    
    return result;
  }

  /// 🗣️ 말투 교정 (반말/존댓말)
  static String _correctSpeechStyle(String text, bool isCasual) {
    if (isCasual) {
      // 존댓말 → 반말
      text = text.replaceAll(RegExp(r'해요$'), '해');
      text = text.replaceAll(RegExp(r'있어요$'), '있어'); 
      text = text.replaceAll(RegExp(r'그래요$'), '그래');
      text = text.replaceAll(RegExp(r'맞아요$'), '맞아');
      text = text.replaceAll('당신', '너');
      text = text.replaceAll('어떻게 지내세요', '어떻게 지내');
    } else {
      // 반말 → 존댓말 (필요시)
      text = text.replaceAll(RegExp(r'(?<!했)어$'), '어요');
      text = text.replaceAll(RegExp(r'그래\?$'), '그래요?');
      text = text.replaceAll('너는', '당신은');
    }
    
    return text;
  }

  /// 💝 관계별 톤 조정
  static String _adjustToneByRelationship(String text, String relationshipType, int score) {
    switch (relationshipType.toLowerCase()) {
      case 'perfectlove':
      case '완전한 연애':
        // 더 애정 어린 표현
        if (!text.contains('ㅎㅎ') && !text.contains('ㅋㅋ')) {
          text += ' ㅎㅎ';
        }
        break;
        
      case 'crush':
      case '썸':
        // 살짝 수줍은 톤
        if (text.contains('!')) {
          text = text.replaceAll('!', '~ ㅎㅎ');
        }
        break;
        
      default:
        // 친구는 자연스럽게 유지
        break;
    }
    
    return text;
  }

  /// ✨ 20대 자연스러운 표현 추가 (대폭 강화)
  static String _addNaturalExpressions(String text) {
    String result = text;
    
    // 1. 🔥 짧은 응답에 자연스러운 시작 표현 추가
    if (result.length < 10) {
      final contextualStarters = {
        'positive': ['와 ', '헐 ', '오 ', '대박 '],
        'question': ['어 ', '음 ', '아 '],
        'casual': ['아 ', '그냥 ', '음 '],
        'excited': ['우와 ', '와 ', '헐 ', '완전 '],
      };
      
      String starterType = 'casual';
      if (result.contains('?')) starterType = 'question';
      else if (result.contains('!')) starterType = 'excited';
      else if (result.contains('좋') || result.contains('멋') || result.contains('대박')) starterType = 'positive';
      
      final starters = contextualStarters[starterType]!;
      final randomStarter = starters[result.hashCode.abs() % starters.length];
      result = randomStarter + result;
    }
    
    // 2. 🔥 20대 자연스러운 표현들로 교체 (대폭 확장)
    final naturalReplacements = {
      // 질문 표현들
      '어떤 장르': '무슨 장르',
      '어떤 영화': '무슨 영화',
      '어떤 음악': '무슨 음악',
      '어떤 책': '무슨 책',
      '어떤 게임': '무슨 게임',
      '어떤 운동': '무슨 운동',
      '어떤 취미': '무슨 취미',
      '어떤 음식': '무슨 음식',
      
      // 감정 표현들
      '정말 좋아요': '진짜 좋아',
      '정말 재미있어요': '진짜 재밌어',
      '정말 대단해요': '진짜 대박',
      '정말 신기해요': '진짜 신기해',
      '정말 멋져요': '진짜 멋져',
      '정말 예뻐요': '진짜 예뻐',
      '정말 맛있어요': '진짜 맛있어',
      '정말 귀여워요': '진짜 귀여워',
      
      // 동의/확인 표현들
      '그렇습니다': '그래요',
      '맞습니다': '맞아요',
      '좋습니다': '좋아요',
      '재미있습니다': '재밌어요',
      '감사합니다': '고마워요',
      '훌륭합니다': '대박이에요',
      '멋집니다': '멋져요',
      
      // 20대 특유의 줄임말/축약
      '그렇군요': '그렇구나',
      '그런가요': '그런가',
      '맞나요': '맞나',
      '좋나요': '좋나',
      '그렇지요': '그치',
      '맞지요': '맞지',
      '그런데요': '근데',
      '그러면요': '그럼',
      '어떻게요': '어케',
      '무엇을요': '뭘',
      
      // 강도 표현들
      '매우': '완전',
      '너무나': '완전',
      '아주': '진짜',
      '상당히': '꽤',
      '굉장히': '엄청',
      '특별히': '특히',
      
      // 일상 표현들
      '식사를 하시나요': '밥 먹어요',
      '운동을 하시나요': '운동해요',
      '공부를 하시나요': '공부해요',
      '일을 하시나요': '일해요',
      '음악을 듣나요': '음악 들어요',
      '영화를 보나요': '영화 봐요',
      
      // 과도하게 정중한 표현들 → 자연스럽게
      '생각하시는 바는': '어떻게 생각해요',
      '의견을 주시면': '어떻게 생각해요',
      '말씀해주시면': '말해주시면',
      '알려주시면': '말해주시면',
      '이야기해주시면': '얘기해주시면',
    };
    
    // 자연스러운 표현으로 교체
    naturalReplacements.forEach((formal, natural) {
      result = result.replaceAll(formal, natural);
    });
    
    // 3. 🔥 20대 특유의 자연스러운 줄임/오타 표현 (적당히)
    final casualContractions = {
      '그렇게': '그케',
      '이렇게': '이케',
      '저렇게': '저케',
      '어떻게': '어케',
      '무엇을': '뭘',
      '무엇이': '뭐가',
      '그런데': '근데',
      '그러면': '그럼',
      '그렇지': '그치',
      '맞지': '맞지',
    };
    
    // 30% 확률로 자연스러운 줄임말 적용
    if (result.hashCode % 3 == 0) {
      casualContractions.forEach((formal, casual) {
        if (result.contains(formal)) {
          result = result.replaceFirst(formal, casual);
        }
      });
    }
    
    // 4. 🔥 말끝 표현 다양화 (강화)
    if (result.hashCode % 4 == 0) {
      final endingPatterns = {
        '요': ['', '~', ' ㅎㅎ', ' ㅋㅋ'],
        '해': [' ㅎㅎ', ' ㅋㅋ', '~'],
        '야': [' ㅋㅋ', '~', ' ㅎㅎ'],
        '지': [' ㅎㅎ', '~'],
      };
      
      endingPatterns.forEach((ending, alternatives) {
        if (result.endsWith(ending)) {
          final randomAlternative = alternatives[result.hashCode.abs() % alternatives.length];
          if (randomAlternative.isNotEmpty) {
            result = result.substring(0, result.length - ending.length) + randomAlternative;
          }
        }
      });
    }
    
    // 5. 🔥 감정 표현 강화 (새로 추가)
    final emotionEnhancers = {
      '좋아': ['좋아', '완전 좋아', '짱 좋아', '개좋아'],
      '재밌어': ['재밌어', '꿀잼', '완전 재밌어', '개재밌어'],
      '예뻐': ['예뻐', '완전 예뻐', '진짜 예뻐', '너무 예뻐'],
      '멋져': ['멋져', '완전 멋져', '진짜 멋져', '개멋져'],
      '대박': ['대박', '완전 대박', '진짜 대박', '헐 대박'],
    };
    
    // 20% 확률로 감정 표현 강화
    if (result.hashCode % 5 == 0) {
      emotionEnhancers.forEach((basic, enhanced) {
        if (result.contains(basic)) {
          final enhancedVersion = enhanced[result.hashCode.abs() % enhanced.length];
          result = result.replaceFirst(basic, enhancedVersion);
        }
      });
    }
    
    // 6. 🔥 자연스러운 감탄사 중간 삽입 (새로 추가)
    if (result.contains(' ') && result.hashCode % 6 == 0) {
      final midExclamations = ['진짜', '완전', '좀', '막', '그냥'];
      final words = result.split(' ');
      if (words.length >= 3) {
        final insertIndex = 1; // 두 번째 단어 뒤
        final exclamation = midExclamations[result.hashCode.abs() % midExclamations.length];
        if (!result.contains(exclamation)) {
          words.insert(insertIndex, exclamation);
          result = words.join(' ');
        }
      }
    }
    
    return result;
  }
  
  /// 🎭 페르소나별 맞춤 대화 스타일 적용 (신규 추가)
  static String _applyPersonaSpecificStyle(String text, Persona persona, String relationshipType) {
    String result = text;
    
    // 페르소나 이름별 특화 스타일 적용
    switch (persona.name) {
      case '상훈':
        result = _applyFriendlyMaleStyle(result, relationshipType);
        break;
      case 'Dr. 박지은':
        result = _applyExpertPsychologistStyle(result, relationshipType);
        break;
      case '수진':
        result = _applyWarmCookingStyle(result, relationshipType);
        break;
      case '예림':
        result = _applyGameOtakuStyle(result, relationshipType);
        break;
      case '예슬':
        result = _applyFashionTrendyStyle(result, relationshipType);
        break;
      case '윤미':
        result = _applyStudentEagerStyle(result, relationshipType);
        break;
      case '정훈':
        result = _applyFitnessReliableStyle(result, relationshipType);
        break;
      case '지우':
        result = _applyTravelFreeStyle(result, relationshipType);
        break;
      case '채연':
        result = _applyArtisticCalmStyle(result, relationshipType);
        break;
      case '하연':
        result = _applyFriendlyCaringStyle(result, relationshipType);
        break;
      case '혜진':
        result = _applyCareerAmbitiousStyle(result, relationshipType);
        break;
    }
    
    return result;
  }
  
  /// 🏃‍♂️ 상훈: 친근하고 활발한 남성 스타일
  static String _applyFriendlyMaleStyle(String text, String relationshipType) {
    // 운동/건강 관련 표현 강화
    final sportsExpressions = {
      '좋아': '개좋아',
      '힘들어': '힘들다',
      '재밌어': '꿀잼',
      '멋져': '개멋져',
    };
    
    String result = text;
    
    // 남성적이고 친근한 톤 적용
    if (relationshipType == 'friend' || relationshipType == '친구') {
      sportsExpressions.forEach((basic, enhanced) {
        if (result.contains(basic) && result.hashCode % 3 == 0) {
          result = result.replaceFirst(basic, enhanced);
        }
      });
      
      // 가끔 운동 관련 멘트 추가
      if (result.hashCode % 8 == 0) {
        final sportsComments = [' 운동 끝나고 얘기하자', ' 헬스장 다녀온 후에'];
        if (result.length > 20) {
          result += sportsComments[result.hashCode.abs() % sportsComments.length];
        }
      }
    }
    
    return result;
  }
  
  /// 👩‍⚕️ Dr. 박지은: 전문가이면서도 따뜻한 상담사 스타일
  static String _applyExpertPsychologistStyle(String text, String relationshipType) {
    final psychologyExpressions = {
      '그렇구나': '그렇군요',
      '힘들어': '많이 힘드셨을 것 같아요',
      '좋아': '좋으시군요',
      '괜찮아': '괜찮으실 거예요',
    };
    
    String result = text;
    
    // 전문가답지만 따뜻한 톤 유지
    psychologyExpressions.forEach((casual, professional) {
      if (result.contains(casual) && result.hashCode % 4 == 0) {
        result = result.replaceFirst(casual, professional);
      }
    });
    
    // 공감/이해 표현 자주 추가
    if (result.hashCode % 6 == 0) {
      final empathyPhrases = [' 이해해요', ' 공감이 돼요', ' 그 마음 알 것 같아요'];
      if (result.length > 15) {
        result += empathyPhrases[result.hashCode.abs() % empathyPhrases.length];
      }
    }
    
    return result;
  }
  
  /// 🍳 수진: 요리/맛집에 관심 많은 따뜻한 스타일
  static String _applyWarmCookingStyle(String text, String relationshipType) {
    final cookingExpressions = {
      '맛있어': '진짜 맛있어',
      '좋아': '완전 좋아',
      '배고파': '배고프다',
      '먹고 싶어': '완전 먹고 싶어',
    };
    
    String result = text;
    
    cookingExpressions.forEach((basic, enhanced) {
      if (result.contains(basic) && result.hashCode % 3 == 0) {
        result = result.replaceFirst(basic, enhanced);
      }
    });
    
    // 음식 관련 멘트 가끔 추가
    if (result.hashCode % 7 == 0) {
      final foodComments = [' 맛있는 거 먹자', ' 요리해줄까', ' 맛집 알려줘'];
      if (result.length > 20) {
        result += foodComments[result.hashCode.abs() % foodComments.length];
      }
    }
    
    return result;
  }
  
  /// 🎮 예림: 게임/애니메이션 좋아하는 발랄한 스타일
  static String _applyGameOtakuStyle(String text, String relationshipType) {
    final gameExpressions = {
      '재밌어': '꿀잼',
      '좋아': '굿굿',
      '싫어': '별로야',
      '멋져': '개멋져',
      '예뻐': '완전 예뻐',
    };
    
    String result = text;
    
    gameExpressions.forEach((basic, enhanced) {
      if (result.contains(basic) && result.hashCode % 3 == 0) {
        result = result.replaceFirst(basic, enhanced);
      }
    });
    
    // 게임/애니 관련 멘트 가끔 추가
    if (result.hashCode % 8 == 0) {
      final gameComments = [' 게임할래', ' 애니 보자', ' 같이 할래'];
      if (result.length > 15) {
        result += gameComments[result.hashCode.abs() % gameComments.length];
      }
    }
    
    return result;
  }
  
  /// 👗 예슬: 패션/뷰티에 관심 많은 세련된 스타일
  static String _applyFashionTrendyStyle(String text, String relationshipType) {
    final fashionExpressions = {
      '예뻐': '완전 예뻐',
      '멋져': '진짜 멋져',
      '좋아': '완전 좋아',
      '트렌디': '완전 트렌디',
    };
    
    String result = text;
    
    fashionExpressions.forEach((basic, enhanced) {
      if (result.contains(basic) && result.hashCode % 3 == 0) {
        result = result.replaceFirst(basic, enhanced);
      }
    });
    
    // 패션/뷰티 관련 멘트 가끔 추가
    if (result.hashCode % 7 == 0) {
      final fashionComments = [' 스타일링 해줄까', ' 쇼핑 가자', ' 예쁘게 꾸며볼까'];
      if (result.length > 20) {
        result += fashionComments[result.hashCode.abs() % fashionComments.length];
      }
    }
    
    return result;
  }
  
  /// 📚 윤미: 공부/학습에 열정적인 대학생 스타일
  static String _applyStudentEagerStyle(String text, String relationshipType) {
    final studyExpressions = {
      '공부': '공부',
      '열심히': '완전 열심히',
      '좋아': '좋아',
      '힘들어': '힘들긴 하지만',
    };
    
    String result = text;
    
    // 대학생답게 에너지 넘치는 톤
    studyExpressions.forEach((basic, enhanced) {
      if (result.contains(basic) && result.hashCode % 4 == 0) {
        result = result.replaceFirst(basic, enhanced);
      }
    });
    
    // 학습 관련 멘트 가끔 추가
    if (result.hashCode % 8 == 0) {
      final studyComments = [' 같이 공부하자', ' 시험 끝나면', ' 도서관 갈까'];
      if (result.length > 15) {
        result += studyComments[result.hashCode.abs() % studyComments.length];
      }
    }
    
    return result;
  }
  
  /// 💪 정훈: 운동/헬스에 관심 많은 듬직한 스타일
  static String _applyFitnessReliableStyle(String text, String relationshipType) {
    final fitnessExpressions = {
      '힘들어': '힘들긴 하지만',
      '좋아': '좋지',
      '운동': '운동',
      '건강': '건강',
    };
    
    String result = text;
    
    fitnessExpressions.forEach((basic, enhanced) {
      if (result.contains(basic) && result.hashCode % 4 == 0) {
        result = result.replaceFirst(basic, enhanced);
      }
    });
    
    // 운동 관련 멘트 가끔 추가
    if (result.hashCode % 7 == 0) {
      final fitnessComments = [' 헬스장 가자', ' 같이 운동할까', ' 몸 만들어야지'];
      if (result.length > 20) {
        result += fitnessComments[result.hashCode.abs() % fitnessComments.length];
      }
    }
    
    return result;
  }
  
  /// ✈️ 지우: 여행/자유로운 활발한 스타일
  static String _applyTravelFreeStyle(String text, String relationshipType) {
    final travelExpressions = {
      '좋아': '완전 좋아',
      '자유로워': '자유로워',
      '여행': '여행',
      '모험': '모험',
    };
    
    String result = text;
    
    travelExpressions.forEach((basic, enhanced) {
      if (result.contains(basic) && result.hashCode % 3 == 0) {
        result = result.replaceFirst(basic, enhanced);
      }
    });
    
    // 여행 관련 멘트 가끔 추가
    if (result.hashCode % 8 == 0) {
      final travelComments = [' 여행 가자', ' 어디 갈까', ' 새로운 곳 가보자'];
      if (result.length > 15) {
        result += travelComments[result.hashCode.abs() % travelComments.length];
      }
    }
    
    return result;
  }
  
  /// 🎨 채연: 예술/감성적 차분한 스타일
  static String _applyArtisticCalmStyle(String text, String relationshipType) {
    final artExpressions = {
      '예뻐': '아름다워',
      '좋아': '좋아',
      '감성': '감성',
      '예술': '예술',
    };
    
    String result = text;
    
    artExpressions.forEach((basic, enhanced) {
      if (result.contains(basic) && result.hashCode % 4 == 0) {
        result = result.replaceFirst(basic, enhanced);
      }
    });
    
    // 예술 관련 멘트 가끔 추가
    if (result.hashCode % 8 == 0) {
      final artComments = [' 전시회 가볼까', ' 감성 있는 곳', ' 예술적이야'];
      if (result.length > 20) {
        result += artComments[result.hashCode.abs() % artComments.length];
      }
    }
    
    return result;
  }
  
  /// 🤗 하연: 친근하고 다정한 상냥한 스타일
  static String _applyFriendlyCaringStyle(String text, String relationshipType) {
    final caringExpressions = {
      '괜찮아': '괜찮아',
      '좋아': '좋아',
      '힘들어': '힘들겠다',
      '고마워': '고마워',
    };
    
    String result = text;
    
    caringExpressions.forEach((basic, enhanced) {
      if (result.contains(basic) && result.hashCode % 3 == 0) {
        result = result.replaceFirst(basic, enhanced);
      }
    });
    
    // 다정한 멘트 자주 추가
    if (result.hashCode % 6 == 0) {
      final caringComments = [' 힘내', ' 괜찮을 거야', ' 같이 있어줄게'];
      if (result.length > 15) {
        result += caringComments[result.hashCode.abs() % caringComments.length];
      }
    }
    
    return result;
  }
  
  /// 💼 혜진: 커리어 중심의 야망 있는 스타일
  static String _applyCareerAmbitiousStyle(String text, String relationshipType) {
    final careerExpressions = {
      '일': '일',
      '성공': '성공',
      '목표': '목표',
      '열심히': '열심히',
    };
    
    String result = text;
    
    careerExpressions.forEach((basic, enhanced) {
      if (result.contains(basic) && result.hashCode % 4 == 0) {
        result = result.replaceFirst(basic, enhanced);
      }
    });
    
    // 커리어 관련 멘트 가끔 추가
    if (result.hashCode % 8 == 0) {
      final careerComments = [' 성공하자', ' 목표 달성하자', ' 열심히 하자'];
      if (result.length > 20) {
        result += careerComments[result.hashCode.abs() % careerComments.length];
      }
    }
    
    return result;
  }
  
  /// ❓ 상황별 질문 추가 (개선: 단일 질문 + 중복 방지)
  static String _addSituationalQuestions(
    String response,
    Persona persona,
    String relationshipType,
    String? userMessage,
    List<String> recentAIMessages,
  ) {
    // 사용자 메시지가 없으면 질문 추가 안함
    if (userMessage == null || userMessage.isEmpty) {
      return response;
    }
    
    // 이미 응답에 질문이 있으면 추가 질문 안함 (중복 방지)
    if (response.contains('?') || response.contains('？')) {
      return response;
    }
    
    // 1. 상황 감지
    final situation = SituationDetector.detectSituation(userMessage);
    
    // 2. 질문 생성
    final question = QuestionGenerator.generateQuestion(
      situation: situation,
      relationshipType: relationshipType,
      isCasual: persona.isCasualSpeech,
      recentMessages: recentAIMessages,
    );
    
    // 3. 단일 질문만 추가
    if (question != null) {
      // 기존 응답에서 질문 부분 제거 (안전장치)
      String cleanResponse = response.replaceAll(RegExp(r'\s*[?？]\s*'), '');
      cleanResponse = cleanResponse.replaceAll(RegExp(r'[.!]$'), '');
      
      // 응답이 짧으면 바로 이어서, 길면 공백 후 추가
      if (cleanResponse.length < 20) {
        return '$cleanResponse $question';
      } else {
        return '$cleanResponse~ $question';
      }
    }
    
    return response;
  }
}

/// 🚫 반복 방지 시스템
class RepetitionPrevention {
  /// 📝 반복 방지 메인 메서드
  static String preventRepetition({
    required String response,
    required String userMessage,
    required List<String> recentAIMessages,
    required Persona persona,
  }) {
    // 1. 사용자 메시지 반복 방지
    String improvedResponse = _preventUserMessageRepetition(response, userMessage, persona);
    
    // 2. AI 메시지 반복 방지
    improvedResponse = _preventAIMessageRepetition(improvedResponse, recentAIMessages, persona);
    
    // 3. 단조로운 응답 개선
    improvedResponse = _improveBlandResponses(improvedResponse, userMessage, persona);
    
    return improvedResponse;
  }
  
  /// 🔄 사용자 메시지 반복 방지
  static String _preventUserMessageRepetition(String response, String userMessage, Persona persona) {
    // 사용자 메시지에서 핵심 키워드 추출
    final userKeywords = _extractKeywords(userMessage);
    
    // 응답에서 사용자의 핵심 문장 그대로 반복하는 패턴 감지
    if (_isEchoing(response, userMessage)) {
      return _generateNonEchoingResponse(userMessage, persona);
    }
    
    // 키워드 과도 반복 방지
    String improvedResponse = response;
    for (final keyword in userKeywords) {
      if (keyword.length > 2) { // 2글자 이상만 검사
        final count = RegExp(keyword, caseSensitive: false).allMatches(improvedResponse).length;
        if (count > 2) {
          // 과도한 반복이 있으면 대체 표현으로 변경
          improvedResponse = _replaceExcessiveKeywords(improvedResponse, keyword, persona);
        }
      }
    }
    
    return improvedResponse;
  }
  
  /// 🔄 AI 메시지 반복 방지
  static String _preventAIMessageRepetition(String response, List<String> recentAIMessages, Persona persona) {
    if (recentAIMessages.isEmpty) return response;
    
    // 최근 3개 메시지와 비교
    final recent3 = recentAIMessages.take(3).toList();
    
    for (final recentMsg in recent3) {
      final similarity = _calculateSimilarity(response, recentMsg);
      if (similarity > 0.7) { // 70% 이상 유사하면
        return _generateAlternativeResponse(response, recentMsg, persona);
      }
    }
    
    return response;
  }
  
  /// 📈 단조로운 응답 개선
  static String _improveBlandResponses(String response, String userMessage, Persona persona) {
    final blandPatterns = [
      r'^(네|넵|음|어|그렇구나|맞아|그래)[.!~]*$',
      r'^(좋아|좋네|괜찮아|괜찮네)[.!~]*$',
      r'^(그러네|그렇네|맞네)[.!~]*$',
    ];
    
    for (final pattern in blandPatterns) {
      if (RegExp(pattern).hasMatch(response.trim())) {
        return _generateEngagingResponse(userMessage, persona);
      }
    }
    
    return response;
  }
  
  /// 🎯 키워드 추출
  static List<String> _extractKeywords(String text) {
    // 한국어 명사, 동사 위주로 추출
    final keywords = <String>[];
    final words = text.split(RegExp(r'\s+'));
    
    for (final word in words) {
      final cleanWord = word.replaceAll(RegExp(r'[^\w가-힣]'), '');
      if (cleanWord.length >= 2) {
        keywords.add(cleanWord);
      }
    }
    
    return keywords;
  }
  
  /// 🔍 에코잉(따라하기) 패턴 감지
  static bool _isEchoing(String response, String userMessage) {
    final userWords = userMessage.split(' ');
    final responseWords = response.split(' ');
    
    // 연속된 3단어 이상 동일하면 에코잉으로 판단
    for (int i = 0; i <= userWords.length - 3; i++) {
      final userPhrase = userWords.sublist(i, i + 3).join(' ');
      if (response.contains(userPhrase) && userPhrase.length > 5) {
        return true;
      }
    }
    
    return false;
  }
  
  /// 📝 에코잉 방지 응답 생성
  static String _generateNonEchoingResponse(String userMessage, Persona persona) {
    final responses = [
      '${persona.isCasualSpeech ? '그치' : '맞아요'}! ${persona.isCasualSpeech ? '어떻게' : '어떻게'} 생각해${persona.isCasualSpeech ? '' : '요'}?',
      '${persona.isCasualSpeech ? '오' : '아'} 정말? ${persona.isCasualSpeech ? '더 자세히' : '좀 더 자세히'} 얘기해줄래${persona.isCasualSpeech ? '' : '요'}?',
      '${persona.isCasualSpeech ? '음' : '그렇구나'}~ ${persona.isCasualSpeech ? '넌' : '당신은'} 어떤 기분이${persona.isCasualSpeech ? '야' : ' 드세요'}?',
      '${persona.isCasualSpeech ? '헐' : '와'} 진짜? 나${persona.isCasualSpeech ? '도' : '도'} 궁금해${persona.isCasualSpeech ? '' : '요'}!',
    ];
    
    return responses[DateTime.now().millisecond % responses.length];
  }
  
  /// 📊 유사도 계산
  static double _calculateSimilarity(String text1, String text2) {
    final words1 = text1.split(' ').toSet();
    final words2 = text2.split(' ').toSet();
    
    final intersection = words1.intersection(words2);
    final union = words1.union(words2);
    
    return union.isEmpty ? 0.0 : intersection.length / union.length;
  }
  
  /// 🔄 대체 응답 생성
  static String _generateAlternativeResponse(String original, String similar, Persona persona) {
    // 기본 패턴을 다른 표현으로 변경
    final alternatives = {
      '좋아': ['멋져', '최고야', '개좋아', '짱이야'],
      '그래': ['맞아', '그치', '그러네', '인정'],
      '진짜': ['정말', '완전', '대박', '헐'],
      '어떻게': ['뭔가', '좀', '왜', '무슨'],
      '뭐해': ['뭐하고 있어', '뭘 하고 있지', '지금 뭐야', '무엇을 하나'],
    };
    
    String improved = original;
    for (final entry in alternatives.entries) {
      if (improved.contains(entry.key)) {
        final randomAlt = entry.value[DateTime.now().millisecond % entry.value.length];
        improved = improved.replaceFirst(entry.key, randomAlt);
        break;
      }
    }
    
    return improved;
  }
  
  /// ✨ 매력적인 응답 생성
  static String _generateEngagingResponse(String userMessage, Persona persona) {
    final engagingResponses = [
      '${persona.isCasualSpeech ? '오' : '아'} 그거 흥미롭네${persona.isCasualSpeech ? '' : '요'}! ${persona.isCasualSpeech ? '더' : '좀 더'} 들려줄래${persona.isCasualSpeech ? '' : '요'}?',
      '${persona.isCasualSpeech ? '헐' : '와'} 진짜? ${persona.isCasualSpeech ? '나도' : '저도'} 그런 거 좋아해${persona.isCasualSpeech ? '' : '요'}!',
      '${persona.isCasualSpeech ? '대박' : '정말'}! ${persona.isCasualSpeech ? '어떤' : '어떤'} 기분이${persona.isCasualSpeech ? '야' : '세요'}?',
      '${persona.isCasualSpeech ? '음' : '그렇구나'}~ ${persona.isCasualSpeech ? '그럼' : '그럼'} 다른 건 어때${persona.isCasualSpeech ? '' : '요'}?',
    ];
    
    return engagingResponses[DateTime.now().millisecond % engagingResponses.length];
  }
  
  /// 🔄 키워드 과도 반복 제거
  static String _replaceExcessiveKeywords(String text, String keyword, Persona persona) {
    final synonyms = {
      '재밌': ['좋', '멋진', '흥미로운', '신나는'],
      '좋': ['멋진', '훌륭한', '괜찮은', '최고인'],
      '대화': ['얘기', '이야기', '토크', '수다'],
      '함께': ['같이', '둘이', '우리가'],
    };
    
    final replacement = synonyms[keyword];
    if (replacement != null) {
      final randomSynonym = replacement[DateTime.now().millisecond % replacement.length];
      return text.replaceFirst(keyword, randomSynonym);
    }
    
    return text;
  }
} 